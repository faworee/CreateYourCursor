<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Cursor Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
    color: #e2e8f0;
    min-height: 100vh;
    padding: 2rem 1rem;
    display: flex;
    justify-content: center;
    align-items: center;
}

.container {
    width: 80vw;
    max-height: 80vh;
    background: rgba(30, 41, 59, 0.9);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(148, 163, 184, 0.15);
    border-radius: 2rem;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
    padding: 2rem;
    padding-left: 3rem;
    overflow-y: auto;
    overflow-x: hidden;
    direction: rtl; 
    padding-right: 0.5rem; 
    
    scrollbar-width: thin; 
    scrollbar-color: rgba(59, 130, 246, 0.6) transparent;
}

.container > * {
    direction: ltr;
}

.container::-webkit-scrollbar {
    width: 8px !important;
    height: 8px !important;
}

.container::-webkit-scrollbar-track {
    background: transparent;
    border-radius: 5px;
}

.container::-webkit-scrollbar-thumb {
    background: rgba(59, 130, 246, 0.6);
    border-radius: 5px;
    border: 2px solid rgba(30, 41, 59, 0.9);
}

.container::-webkit-scrollbar-thumb:hover {
    background: rgba(59, 130, 246, 0.8);
}

.file-input-label {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 4px;
    background-color: #007bff; 
    color: white;
    cursor: pointer; 
    font-weight: 600;
    transition: background-color 0.2s;
}

.file-input-label:hover {
    background-color: #0056b3; 
}

#imageUpload {
    opacity: 0;
    position: absolute;
    width: 0.1px;
    height: 0.1px;
    overflow: hidden;
    z-index: -1; 
}

        .main-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-top: 2rem;
        }

        @media (min-width: 768px) {
            .main-grid {
                grid-template-columns: repeat(2, 1fr);
            }

             .download-section {
             grid-column: span 2;
            }
        }

        @media (min-width: 1280px) {
            .main-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            .preview-section {
                grid-row: span 1;
            }
             .download-section {
        grid-column: span 3;
        display: flex;
        justify-content: center;
    }
  
    .download-section > div {
        width: 50%; 
    }
        }

        .section {
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 1rem;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .section:hover {
            border-color: rgba(59, 130, 246, 0.2);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .section-title {
            font-size: 1.125rem;
            font-weight: 700;
            color: #f1f5f9;
            margin-bottom: 1rem;
        }

        canvas {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 1rem;
            width: 100%;
            height: 100%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .canvas-container {
            width: 100%;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 1rem;
            padding: 1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: linear-gradient(90deg, #1e293b 0%, #334155 100%);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 2px solid #1e40af;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 2px solid #1e40af;
            cursor: pointer;
        }

        .shape-button {
            padding: 0.75rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            border: 2px solid transparent;
            background: #4b5563;
            color: #e5e7eb;
            transition: all 0.3s ease;
        }

        .shape-button:hover {
            transform: translateY(-2px);
            border-color: rgba(59, 130, 246, 0.4);
        }

        .shape-button.selected {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 52px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #4b5563;
            border-radius: 28px;
            transition: 0.4s;
        }

        .toggle-switch input:checked + .slider {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        }

        .toggle-switch .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background: white;
            border-radius: 50%;
            transition: 0.4s;
        }

        .toggle-switch input:checked + .slider:before {
            transform: translateX(24px);
        }

        .input-field {
            background: #1e293b;
            border: 2px solid #475569;
            border-radius: 0.5rem;
            padding: 0.5rem;
            color: #e2e8f0;
            font-size: 0.875rem;
            width: 80px;
            text-align: center;
        }

        .input-field:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .btn-primary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border: none;
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            color: white;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(16, 185, 129, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            border: none;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border: none;
            border-radius: 0.5rem;
            padding: 0.625rem 1rem;
            color: white;
            font-weight: 500;
            cursor: pointer;
        }

        .btn-copy, .btn-paste {
            border-radius: 0.25rem;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: white;
            font-size: 0.75rem;
            border: none;
        }

        .btn-copy {
            background: #8b5cf6;
        }

        .btn-paste {
            background: #10b981;
        }

        input[type="color"] {
            width: 40px;
            height: 40px;
            cursor: pointer;
            border: 2px solid #3b82f6;
            border-radius: 0.5rem;
            -webkit-appearance: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 0.25rem;
        }

      .file-input {
    position: relative;
    cursor: pointer;
    direction: ltr;  
}


.file-input-label {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    background: #374151;
    border: 2px dashed #6b7280;
    border-radius: 0.75rem;
    color: #d1d5db;
    cursor: pointer;
    transition: all 0.3s ease;
    direction: ltr;  
    text-align: center;  
}
        .file-input:hover .file-input-label {
            border-color: #3b82f6;
            background: #4b5563;
        }

        .gradient-color-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: #334155;
            padding: 0.5rem;
            border-radius: 0.5rem;
        }

        .remove-gradient-color-btn {
            background: #ef4444;
            color: white;
            border-radius: 0.25rem;
            width: 1.75rem;
            height: 1.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
        }
#imageUpload {
    opacity: 0;
}

        select {
            background: #1e293b;
            border: 2px solid #475569;
            border-radius: 0.5rem;
            padding: 0.625rem;
            color: #e2e8f0;
            cursor: pointer;
            width: 100%;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            text-align: center;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 50%, #ec4899 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Custom Cursor Creator</h1>
        <p class="subtitle">Design beautiful cursors for rhythm games</p>
        
        <div class="main-grid">
            <div class="section preview-section">
                <div class="section-title">üé® Preview</div>
                <div class="canvas-container">
                    <canvas id="cursorCanvas" width="400" height="400"></canvas>
                </div>
            </div>

            <div class="section">
                <div class="section-title">‚≠ê Shape</div>
                <div class="grid grid-cols-2 gap-2">
                    <button class="shape-button selected" data-shape="squircle">Squircle</button>
                    <button class="shape-button" data-shape="circle">Circle</button>
                    <button class="shape-button" data-shape="square">Square</button>
                    <button class="shape-button" data-shape="triangle">Triangle</button>
                    <button class="shape-button" data-shape="star">Star</button>
                    <button class="shape-button" data-shape="hexagon">Hexagon</button>
                    <button class="shape-button" data-shape="heart">Heart</button>
                    <button class="shape-button" data-shape="diamond">Diamond</button>
                    <button class="shape-button" data-shape="pentagon">Pentagon</button>
                    <button class="shape-button" data-shape="trapezoid">Trapezoid</button>
                </div>
                <div id="squircle-options" class="mt-4 hidden">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-sm">Roundness</label>
                        <input type="number" id="squircleRoundnessInput" class="input-field" min="2" max="10" step="0.1" value="4.0">
                    </div>
                    <input type="range" id="squircleRoundness" min="2" max="10" value="4" step="0.1">
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">üé® Fill</div>
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">Use Solid Fill</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useSolidFill" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center justify-between">
                        <label class="text-sm">Use Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useGradientFill">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="useOutlineGradientFillOption" class="flex items-center justify-between hidden">
                        <label class="text-sm">Use Outline Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useOutlineGradientFill">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center justify-between hidden" id="smoothFillContainer">
                        <label class="text-sm">Smooth Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useSmoothFillGradient" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="solid-fill-options">
                        <div class="flex items-center justify-between mb-4" id="solidFillColorContainer">
                            <label class="text-sm">Color</label>
                            <input type="color" id="solidFillColor" value="#ffffff">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-sm">Opacity</label>
                                <input type="number" id="fillOpacityInput" class="input-field" min="0" max="1" step="0.01" value="1.00">
                            </div>
                            <input type="range" id="fillOpacity" min="0" max="1" value="1" step="0.01">
                        </div>
                        <div id="gradient-fill-options" class="mt-4 hidden">
                            <div id="gradient-fill-colors" class="flex flex-col gap-2 mb-2"></div>
                            <button id="addFillColor" class="w-full btn-secondary">Add Color</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">‚ú® Outline</div>
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">Use Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useGradientOutline">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="useFillGradientOutlineOption" class="flex items-center justify-between hidden">
                        <label class="text-sm">Use Fill Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useFillGradientOutline">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="flex items-center justify-between hidden" id="smoothOutlineContainer">
                        <label class="text-sm">Smooth Gradient</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="useSmoothOutlineGradient" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="solid-outline-options">
                        <div class="flex items-center justify-between mb-4">
                            <label class="text-sm">Color</label>
                            <input type="color" id="outlineColor" value="#4299e1">
                        </div>
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm">Opacity</label>
                            <input type="number" id="outlineOpacityInput" class="input-field" min="0" max="1" step="0.01" value="1.00">
                        </div>
                        <input type="range" id="outlineOpacity" min="0" max="1" value="1" step="0.01">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm">Thickness</label>
                            <input type="number" id="borderThicknessInput" class="input-field" min="0" max="50" value="10">
                        </div>
                        <input type="range" id="borderThickness" min="0" max="50" value="10">
                    </div>
                    <div id="gradient-outline-options" class="hidden">
                        <div id="gradient-outline-colors" class="flex flex-col gap-2 mb-2"></div>
                        <button id="addOutlineColor" class="w-full btn-secondary">Add Color</button>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">‚ú® Glow</div>
                <div class="space-y-4">
                    <div class="flex items-center justify-between">
                        <label class="text-sm">Add Glow</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="addGlow">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div id="glow-options" class="space-y-4 hidden">
                        <div class="flex items-center justify-between">
                            <label class="text-sm">Use Outline Color</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="useOutlineGlow">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div id="separate-glow-options">
                            <div id="glow-color-option" class="flex items-center justify-between mb-4">
                                <label class="text-sm">Color</label>
                                <input type="color" id="glowColorInput" value="#4299e1">
                            </div>
                            <div>
                                <div class="flex justify-between items-center mb-2">
                                    <label class="text-sm">Amount</label>
                                    <input type="number" id="glowAmountInput" class="input-field" min="0" max="1" step="0.01" value="0.50">
                                </div>
                                <input type="range" id="glowAmount" min="0" max="1" value="0.5" step="0.01">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
              <div class="section" style="direction: ltr;">
    <div class="section-title">üñºÔ∏è Image</div>
    <div class="file-input">
        <input type="file" id="imageUpload" accept="image/*">
        <label for="imageUpload" class="file-input-label">Choose Image</label>
    </div>
</div>
                <div id="image-options" class="space-y-4 mt-4 hidden">
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm">Scale</label>
                            <input type="number" id="imageScaleInput" class="input-field" min="0.01" max="2" step="0.01" value="1.00">
                        </div>
                        <input type="range" id="imageScale" min="0.01" max="2" value="1" step="0.01">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm">Opacity</label>
                            <input type="number" id="imageOpacityInput" class="input-field" min="0" max="1" step="0.01" value="1.00">
                        </div>
                        <input type="range" id="imageOpacity" min="0" max="1" value="1" step="0.01">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-sm">Rotation</label>
                            <input type="number" id="imageRotationInput" class="input-field" min="0" max="360" value="0">
                        </div>
                        <input type="range" id="imageRotation" min="0" max="360" value="0">
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-sm">Position X</label>
                                <input type="number" id="imageOffsetXInput" class="input-field" min="-100" max="100" value="0">
                            </div>
                            <input type="range" id="imageOffsetX" min="-100" max="100" value="0">
                        </div>
                        <div>
                            <div class="flex justify-between items-center mb-2">
                                <label class="text-sm">Position Y</label>
                                <input type="number" id="imageOffsetYInput" class="input-field" min="-100" max="100" value="0">
                            </div>
                            <input type="range" id="imageOffsetY" min="-100" max="100" value="0">
                        </div>
                    </div>
                    <button id="removeImageBtn" class="w-full btn-danger">Remove Image</button>
                </div>
            </div>

         <div class="section download-section">
    <div>
        <div class="section-title">üíæ Download</div>
        <div class="space-y-4">
            <div>
                <label class="text-sm block mb-2">Export Size</label>
                <select id="exportSize">
                    <option value="512">512x512</option>
                    <option value="1024">1024x1024</option>
                    <option value="2048" selected>2048x2048</option>
                    <option value="4096">4096x4096</option>
                </select>
            </div>
            <button id="downloadBtn" class="btn-primary">Download PNG</button>
        </div>
   
    </div>

</div>
        </div>
    </div>
    
    <script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('cursorCanvas');
    const ctx = canvas.getContext('2d');
    
    let currentShape = 'squircle';
    let squircleRoundness = 4;
    let solidFillColor = '#ffffff';
    let fillOpacity = 1;
    let outlineColor = '#4299e1';
    let outlineOpacity = 1;
    let borderThickness = 10;
    let glowColor = '#4299e1';
    let glowAmount = 0.5;
    let uploadedImage = null;
    let imageScale = 1;
    let imageOpacity = 1;
    let imageRotation = 0;
    let imageOffsetX = 0;
    let imageOffsetY = 0;
    let copiedColors = null;

    const syncSliderInput = (slider, input, callback) => {
        const isInt = slider.step === "1";
        const precision = isInt ? 0 : 2;
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            input.value = value.toFixed(precision);
            callback(value);
        });
        input.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            if (!isNaN(value)) {
                slider.value = value;
                callback(value);
            }
        });
    };

    const updateControlsVisibility = () => {
        const isSolidFillActive = document.getElementById('useSolidFill').checked;
        const isGradientFillActive = document.getElementById('useGradientFill').checked;
        const isGradientOutlineActive = document.getElementById('useGradientOutline').checked;
        const isGlowActive = document.getElementById('addGlow').checked;
        const isOutlineGlowActive = document.getElementById('useOutlineGlow').checked;
        const isSquircle = currentShape === 'squircle';

        document.getElementById('solid-fill-options').classList.toggle('hidden', !isSolidFillActive);
        document.getElementById('gradient-fill-options').classList.toggle('hidden', !isGradientFillActive);
        document.getElementById('solidFillColorContainer').classList.toggle('hidden', isGradientFillActive);
        document.getElementById('gradient-outline-options').classList.toggle('hidden', !isGradientOutlineActive);
        document.getElementById('solid-outline-options').classList.toggle('hidden', isGradientOutlineActive);
        document.getElementById('glow-options').classList.toggle('hidden', !isGlowActive);
        document.getElementById('glow-color-option').classList.toggle('hidden', isOutlineGlowActive);
        document.getElementById('squircle-options').classList.toggle('hidden', !isSquircle);
        
        document.getElementById('useOutlineGradientFillOption').classList.toggle('hidden', !(isGradientFillActive && isGradientOutlineActive));
        document.getElementById('useFillGradientOutlineOption').classList.toggle('hidden', !(isGradientFillActive && isGradientOutlineActive));
        
        document.getElementById('smoothFillContainer').classList.toggle('hidden', !isGradientFillActive);
        document.getElementById('smoothOutlineContainer').classList.toggle('hidden', !isGradientOutlineActive);
        
        document.getElementById('image-options').classList.toggle('hidden', !uploadedImage);
        document.getElementById('removeImageBtn').classList.toggle('hidden', !uploadedImage);
    };

    const hexToRgbA = (hex, alpha) => {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
        }
        return `rgba(0,0,0,${alpha})`;
    };

    const getGradientColors = (container) => {
        return Array.from(container.querySelectorAll('input[type="color"]')).map(input => input.value);
    };

    const drawShape = (path, center, size) => {
        switch (currentShape) {
            case 'squircle':
                const n = squircleRoundness;
                const r = size / 2;
                path.moveTo(center.x + r, center.y);
                for (let i = 0; i <= 360; i++) {
                    const angle = (i * Math.PI) / 180;
                    const cos_t = Math.cos(angle);
                    const sin_t = Math.sin(angle);
                    const x = center.x + r * Math.sign(cos_t) * Math.pow(Math.abs(cos_t), 2 / n);
                    const y = center.y + r * Math.sign(sin_t) * Math.pow(Math.abs(sin_t), 2 / n);
                    path.lineTo(x, y);
                }
                path.closePath();
                break;
            case 'circle':
                path.arc(center.x, center.y, size / 2, 0, 2 * Math.PI);
                break;
            case 'square':
                const s = size / Math.sqrt(2);
                path.rect(center.x - s / 2, center.y - s / 2, s, s);
                break;
            case 'triangle':
                const height = size * Math.sqrt(3) / 2;
                path.moveTo(center.x, center.y - height / 2);
                path.lineTo(center.x - size / 2, center.y + height / 2);
                path.lineTo(center.x + size / 2, center.y + height / 2);
                path.closePath();
                break;
            case 'star':
                const outerRadius = size / 2;
                const innerRadius = outerRadius * 0.4;
                for (let i = 0; i < 10; i++) {
                    const angle = (i * Math.PI) / 5;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = center.x + radius * Math.cos(angle - Math.PI / 2);
                    const y = center.y + radius * Math.sin(angle - Math.PI / 2);
                    if (i === 0) path.moveTo(x, y);
                    else path.lineTo(x, y);
                }
                path.closePath();
                break;
            case 'hexagon':
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = center.x + (size / 2) * Math.cos(angle);
                    const y = center.y + (size / 2) * Math.sin(angle);
                    if (i === 0) path.moveTo(x, y);
                    else path.lineTo(x, y);
                }
                path.closePath();
                break;
            case 'heart':
                const heartScale = size / 32;
                for (let t = 0; t <= 2 * Math.PI; t += 0.01) {
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    if (t === 0) {
                        path.moveTo(center.x + x * heartScale, center.y - y * heartScale);
                    } else {
                        path.lineTo(center.x + x * heartScale, center.y - y * heartScale);
                    }
                }
                path.closePath();
                break;
            case 'diamond':
                path.moveTo(center.x, center.y - size/2);
                path.lineTo(center.x + size/2, center.y);
                path.lineTo(center.x, center.y + size/2);
                path.lineTo(center.x - size/2, center.y);
                path.closePath();
                break;
            case 'pentagon':
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * 2 * Math.PI - Math.PI / 2;
                    const x = center.x + (size / 2) * Math.cos(angle);
                    const y = center.y + (size / 2) * Math.sin(angle);
                    if (i === 0) path.moveTo(x, y);
                    else path.lineTo(x, y);
                }
                path.closePath();
                break;
            case 'trapezoid':
                const widthTop = size * 0.5;
                const widthBottom = size * 0.8;
                const heightTrapezoid = size * 0.8;
                path.moveTo(center.x - widthTop/2, center.y - heightTrapezoid/2);
                path.lineTo(center.x + widthTop/2, center.y - heightTrapezoid/2);
                path.lineTo(center.x + widthBottom/2, center.y + heightTrapezoid/2);
                path.lineTo(center.x - widthBottom/2, center.y + heightTrapezoid/2);
                path.closePath();
                break;
        }
    };

    const drawCursor = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const center = { x: canvas.width / 2, y: canvas.height / 2 };
        const size = Math.min(300, Math.min(canvas.width, canvas.height) - 40);
        
        const fillPath = new Path2D();
        drawShape(fillPath, center, size - borderThickness);
        
        let fillDrawn = false;
        if (document.getElementById('useSolidFill').checked) {
            if (document.getElementById('useGradientFill').checked) {
                let colors;
                
                if (document.getElementById('useOutlineGradientFill').checked && document.getElementById('useGradientOutline').checked) {
                    colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                } else {
                    colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                }
                
                if (colors.length > 1) {
                    if (document.getElementById('useSmoothFillGradient').checked) {
                        const gradient = ctx.createLinearGradient(0, center.y - (size - borderThickness) / 2, 0, center.y + (size - borderThickness) / 2);
                        const step = 1 / (colors.length - 1);
                        colors.forEach((color, index) => {
                            gradient.addColorStop(step * index, hexToRgbA(color, fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                        ctx.fill(fillPath);
                        fillDrawn = true;
                    } else {
                        const sections = colors.length;
                        const sectionHeight = (size - borderThickness) / sections;
                        colors.forEach((color, index) => {
                            ctx.save();
                            const sectionPath = new Path2D();
                            const clipY = center.y - (size - borderThickness) / 2 + (index * sectionHeight);
                            sectionPath.rect(center.x - size, clipY, size * 2, sectionHeight);
                            ctx.clip(sectionPath);
                            ctx.clip(fillPath);
                            ctx.fillStyle = hexToRgbA(color, fillOpacity);
                            ctx.fill(fillPath);
                            ctx.restore();
                        });
                        fillDrawn = true;
                    }
                }
            }
            if (!fillDrawn) {
                ctx.fillStyle = hexToRgbA(solidFillColor, fillOpacity);
                ctx.fill(fillPath);
            }
        }
        
        if (uploadedImage) {
            ctx.save();
            ctx.clip(fillPath);
            ctx.globalAlpha = imageOpacity;
            
            const shapeSize = size - borderThickness;
            const imgAspect = uploadedImage.width / uploadedImage.height;
            const shapeAspect = 1; // shapes are square
            
            // Use "cover" behavior - fill the entire shape
            let imgWidth, imgHeight;
            if (imgAspect > shapeAspect) {
                // Image is wider - fit to height
                imgHeight = shapeSize;
                imgWidth = imgHeight * imgAspect;
            } else {
                // Image is taller - fit to width
                imgWidth = shapeSize;
                imgHeight = imgWidth / imgAspect;
            }
            
            const scaledWidth = imgWidth * imageScale;
            const scaledHeight = imgHeight * imageScale;

            ctx.translate(center.x, center.y);
            ctx.translate(imageOffsetX, imageOffsetY);
            ctx.rotate(imageRotation * Math.PI / 180);
            ctx.drawImage(uploadedImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
            
            ctx.restore();
        }

        const outlinePath = new Path2D();
        drawShape(outlinePath, center, size - borderThickness / 2);

        if (document.getElementById('addGlow').checked) {
            let currentGlowColor;
            if (document.getElementById('useOutlineGlow').checked) {
                if (document.getElementById('useGradientOutline').checked) {
                    let colors;
                    
                    if (document.getElementById('useFillGradientOutline').checked && document.getElementById('useGradientFill').checked) {
                        colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                    } else {
                        colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                    }
                    
                    currentGlowColor = colors.length > 0 ? colors[0] : outlineColor;
                } else {
                    currentGlowColor = outlineColor;
                }
            } else {
                currentGlowColor = glowColor;
            }
            ctx.shadowBlur = borderThickness * 2 * glowAmount;
            ctx.shadowColor = currentGlowColor;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        } else {
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';
        }

        if (borderThickness > 0) {
            if (document.getElementById('useGradientOutline').checked) {
                let colors;
                
                if (document.getElementById('useFillGradientOutline').checked && document.getElementById('useGradientFill').checked) {
                    colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                } else {
                    colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                }
                
                if (colors.length > 1) {
                    if (document.getElementById('useSmoothOutlineGradient').checked) {
                        const gradient = ctx.createLinearGradient(0, center.y - size/2, 0, center.y + size/2);
                        const step = 1 / (colors.length - 1);
                        colors.forEach((color, index) => {
                            gradient.addColorStop(step * index, hexToRgbA(color, outlineOpacity));
                        });
                        ctx.strokeStyle = gradient;
                    } else {
                        const sections = colors.length;
                        const sectionHeight = size / sections;
                        colors.forEach((color, index) => {
                            ctx.save();
                            const sectionPath = new Path2D();
                            const clipY = center.y - size / 2 + (index * sectionHeight);
                            sectionPath.rect(center.x - size, clipY, size * 2, sectionHeight);
                            ctx.clip(sectionPath);
                            ctx.strokeStyle = hexToRgbA(color, outlineOpacity);
                            ctx.lineWidth = borderThickness;
                            ctx.stroke(outlinePath);
                            ctx.restore();
                        });
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                        return;
                    }
                } else if (colors.length === 1) {
                    ctx.strokeStyle = hexToRgbA(colors[0], outlineOpacity);
                } else {
                    ctx.strokeStyle = hexToRgbA(outlineColor, outlineOpacity);
                }
            } else {
                ctx.strokeStyle = hexToRgbA(outlineColor, outlineOpacity);
            }
            ctx.lineWidth = borderThickness;
            ctx.stroke(outlinePath);
        }
        
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
    };

    const addGradientColorInput = (container, defaultColor) => {
        const colorWrapper = document.createElement('div');
        colorWrapper.className = 'gradient-color-input-group';
        colorWrapper.innerHTML = `
            <input type="color" value="${defaultColor}">
            <button class="btn-copy" title="Copy">üìã</button>
            <button class="btn-paste" title="Paste">üìÑ</button>
            <button class="remove-gradient-color-btn">&times;</button>
        `;
        container.appendChild(colorWrapper);
        
        const colorInput = colorWrapper.querySelector('input');
        const copyBtn = colorWrapper.querySelector('.btn-copy');
        const pasteBtn = colorWrapper.querySelector('.btn-paste');
        const removeBtn = colorWrapper.querySelector('.remove-gradient-color-btn');
        
        colorInput.addEventListener('input', drawCursor);
        
        copyBtn.addEventListener('click', () => {
            copiedColors = { colors: [colorInput.value], source: container };
            copyBtn.textContent = '‚úì';
            setTimeout(() => { copyBtn.textContent = 'üìã'; }, 1000);
        });
        
        pasteBtn.addEventListener('click', () => {
            if (copiedColors && copiedColors.colors && copiedColors.colors.length > 0) {
                colorInput.value = copiedColors.colors[0];
                drawCursor();
                pasteBtn.textContent = '‚úì';
                setTimeout(() => { pasteBtn.textContent = 'üìÑ'; }, 1000);
            }
        });
        
        removeBtn.addEventListener('click', () => {
            if (container.children.length > 1) {
                colorWrapper.remove();
                drawCursor();
            }
        });
        
        drawCursor();
    };

    const initializeGradientColors = (container, colorsArray) => {
        container.innerHTML = '';
        colorsArray.forEach(color => {
            addGradientColorInput(container, color);
        });
    };

    initializeGradientColors(document.getElementById('gradient-fill-colors'), ['#ff0000', '#0000ff']);
    initializeGradientColors(document.getElementById('gradient-outline-colors'), ['#00ff00', '#0000ff']);

    syncSliderInput(document.getElementById('fillOpacity'), document.getElementById('fillOpacityInput'), (v) => { fillOpacity = v; drawCursor(); });
    syncSliderInput(document.getElementById('outlineOpacity'), document.getElementById('outlineOpacityInput'), (v) => { outlineOpacity = v; drawCursor(); });
    syncSliderInput(document.getElementById('borderThickness'), document.getElementById('borderThicknessInput'), (v) => { borderThickness = v; drawCursor(); });
    syncSliderInput(document.getElementById('glowAmount'), document.getElementById('glowAmountInput'), (v) => { glowAmount = v; drawCursor(); });
    syncSliderInput(document.getElementById('imageScale'), document.getElementById('imageScaleInput'), (v) => { imageScale = v; drawCursor(); });
    syncSliderInput(document.getElementById('imageOpacity'), document.getElementById('imageOpacityInput'), (v) => { imageOpacity = v; drawCursor(); });
    syncSliderInput(document.getElementById('imageRotation'), document.getElementById('imageRotationInput'), (v) => { imageRotation = v; drawCursor(); });
    syncSliderInput(document.getElementById('imageOffsetX'), document.getElementById('imageOffsetXInput'), (v) => { imageOffsetX = v; drawCursor(); });
    syncSliderInput(document.getElementById('imageOffsetY'), document.getElementById('imageOffsetYInput'), (v) => { imageOffsetY = v; drawCursor(); });
    syncSliderInput(document.getElementById('squircleRoundness'), document.getElementById('squircleRoundnessInput'), (v) => { squircleRoundness = v; drawCursor(); });

    document.querySelectorAll('.shape-button').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.shape-button').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            currentShape = btn.dataset.shape;
            updateControlsVisibility();
            drawCursor();
        });
    });

    document.getElementById('useSolidFill').addEventListener('change', () => { updateControlsVisibility(); drawCursor(); });
    document.getElementById('useGradientFill').addEventListener('change', (e) => {
        if (e.target.checked && document.getElementById('useOutlineGradientFill').checked) {
            document.getElementById('useOutlineGradientFill').checked = false;
        }
        updateControlsVisibility();
        drawCursor();
    });
    document.getElementById('useGradientOutline').addEventListener('change', (e) => {
        if (e.target.checked && document.getElementById('useFillGradientOutline').checked) {
            document.getElementById('useFillGradientOutline').checked = false;
        }
        updateControlsVisibility();
        drawCursor();
    });
    document.getElementById('useOutlineGradientFill').addEventListener('change', (e) => {
        if (e.target.checked) document.getElementById('useFillGradientOutline').checked = false;
        drawCursor();
    });
    document.getElementById('useFillGradientOutline').addEventListener('change', (e) => {
        if (e.target.checked) document.getElementById('useOutlineGradientFill').checked = false;
        drawCursor();
    });
    document.getElementById('addGlow').addEventListener('change', () => { updateControlsVisibility(); drawCursor(); });
    document.getElementById('useOutlineGlow').addEventListener('change', () => { updateControlsVisibility(); drawCursor(); });
    document.getElementById('useSmoothFillGradient').addEventListener('change', drawCursor);
    document.getElementById('useSmoothOutlineGradient').addEventListener('change', drawCursor);

    document.getElementById('solidFillColor').addEventListener('input', (e) => { solidFillColor = e.target.value; drawCursor(); });
    document.getElementById('outlineColor').addEventListener('input', (e) => { outlineColor = e.target.value; drawCursor(); });
    document.getElementById('glowColorInput').addEventListener('input', (e) => { glowColor = e.target.value; drawCursor(); });

    document.getElementById('addFillColor').addEventListener('click', () => {
        addGradientColorInput(document.getElementById('gradient-fill-colors'), '#000000');
    });
    document.getElementById('addOutlineColor').addEventListener('click', () => {
        addGradientColorInput(document.getElementById('gradient-outline-colors'), '#000000');
    });

    document.getElementById('imageUpload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    imageScale = 1;
                    document.getElementById('imageScale').value = imageScale;
                    document.getElementById('imageScaleInput').value = imageScale.toFixed(2);
                    drawCursor();
                    updateControlsVisibility();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('removeImageBtn').addEventListener('click', () => {
        uploadedImage = null;
        document.getElementById('imageUpload').value = '';
        updateControlsVisibility();
        drawCursor();
    });

    document.getElementById('downloadBtn').addEventListener('click', () => {
        const exportSize = parseInt(document.getElementById('exportSize').value);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = exportSize;
        tempCanvas.height = exportSize;
        const tempCtx = tempCanvas.getContext('2d');
        
        const center = { x: tempCanvas.width / 2, y: tempCanvas. height / 2 };
        const scaleFactor = exportSize / 400;
        const size = exportSize * 0.95;
        const scaledBorderThickness = borderThickness * scaleFactor;
        const glowSize = document.getElementById('addGlow').checked ? scaledBorderThickness * 2 * glowAmount : 0;
        
        const fillPath = new Path2D();
        drawShape(fillPath, center, size - scaledBorderThickness);

        let fillDrawn = false;
        if (document.getElementById('useSolidFill').checked) {
            if (document.getElementById('useGradientFill').checked) {
                let colors;
                
                if (document.getElementById('useOutlineGradientFill').checked && document.getElementById('useGradientOutline').checked) {
                    colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                } else {
                    colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                }
                
                if (colors.length > 1) {
                    if (document.getElementById('useSmoothFillGradient').checked) {
                        const gradient = tempCtx.createLinearGradient(0, center.y - (size - scaledBorderThickness) / 2, 0, center.y + (size - scaledBorderThickness) / 2);
                        const step = 1 / (colors.length - 1);
                        colors.forEach((color, index) => {
                            gradient.addColorStop(step * index, hexToRgbA(color, fillOpacity));
                        });
                        tempCtx.fillStyle = gradient;
                        tempCtx.fill(fillPath);
                        fillDrawn = true;
                    } else {
                        const sections = colors.length;
                        const sectionHeight = (size - scaledBorderThickness) / sections;
                        colors.forEach((color, index) => {
                            tempCtx.save();
                            const sectionPath = new Path2D();
                            const clipY = center.y - (size - scaledBorderThickness) / 2 + (index * sectionHeight);
                            sectionPath.rect(center.x - size, clipY, size * 2, sectionHeight);
                            tempCtx.clip(sectionPath);
                            tempCtx.clip(fillPath);
                            tempCtx.fillStyle = hexToRgbA(color, fillOpacity);
                            tempCtx.fill(fillPath);
                            tempCtx.restore();
                        });
                        fillDrawn = true;
                    }
                }
            }
            if (!fillDrawn) {
                tempCtx.fillStyle = hexToRgbA(solidFillColor, fillOpacity);
                tempCtx.fill(fillPath);
            }
        }
        
        if (uploadedImage) {
            tempCtx.save();
            tempCtx.clip(fillPath);
            tempCtx.globalAlpha = imageOpacity;
            
            const shapeSize = size - scaledBorderThickness;
            const imgAspect = uploadedImage.width / uploadedImage.height;
            let imgWidth = shapeSize;
            let imgHeight = shapeSize;
            
            if (imgAspect > 1) {
                imgHeight = shapeSize / imgAspect;
            } else {
                imgWidth = shapeSize * imgAspect;
            }
            
            const scaledWidth = imgWidth * imageScale;
            const scaledHeight = imgHeight * imageScale;
            const scaledOffsetX = imageOffsetX * scaleFactor;
            const scaledOffsetY = imageOffsetY * scaleFactor;

            tempCtx.translate(center.x + scaledOffsetX, center.y + scaledOffsetY);
            tempCtx.rotate(imageRotation * Math.PI / 180);
            tempCtx.drawImage(uploadedImage, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
            
            tempCtx.restore();
        }

        const outlinePath = new Path2D();
        drawShape(outlinePath, center, size - scaledBorderThickness / 2);

        if (document.getElementById('addGlow').checked) {
            let currentGlowColor = glowColor;
            if (document.getElementById('useOutlineGlow').checked) {
                if (document.getElementById('useGradientOutline').checked) {
                    let colors;
                    
                    if (document.getElementById('useFillGradientOutline').checked && document.getElementById('useGradientFill').checked) {
                        colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                    } else {
                        colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                    }
                    
                    if (colors.length > 0) currentGlowColor = colors[0];
                } else {
                    currentGlowColor = outlineColor;
                }
            }
            tempCtx.shadowBlur = scaledBorderThickness * 2 * glowAmount;
            tempCtx.shadowColor = currentGlowColor;
            tempCtx.shadowOffsetX = 0;
            tempCtx.shadowOffsetY = 0;
        }
        
        if (scaledBorderThickness > 0) {
            if (document.getElementById('useGradientOutline').checked) {
                let colors;
                
                if (document.getElementById('useFillGradientOutline').checked && document.getElementById('useGradientFill').checked) {
                    colors = getGradientColors(document.getElementById('gradient-fill-colors'));
                } else {
                    colors = getGradientColors(document.getElementById('gradient-outline-colors'));
                }
                
                if (colors.length > 1) {
                    if (document.getElementById('useSmoothOutlineGradient').checked) {
                        const gradient = tempCtx.createLinearGradient(0, center.y - size/2, 0, center.y + size/2);
                        const step = 1 / (colors.length - 1);
                        colors.forEach((color, index) => {
                            gradient.addColorStop(step * index, hexToRgbA(color, outlineOpacity));
                        });
                        tempCtx.strokeStyle = gradient;
                    } else {
                        const sections = colors.length;
                        const sectionHeight = size / sections;
                        colors.forEach((color, index) => {
                            tempCtx.save();
                            const sectionPath = new Path2D();
                            const clipY = center.y - size / 2 + (index * sectionHeight);
                            sectionPath.rect(center.x - size, clipY, size * 2, sectionHeight);
                            tempCtx.clip(sectionPath);
                            tempCtx.strokeStyle = hexToRgbA(color, outlineOpacity);
                            tempCtx.lineWidth = scaledBorderThickness;
                            tempCtx.stroke(outlinePath);
                            tempCtx.restore();
                        });
                        tempCtx.shadowBlur = 0;
                        tempCtx.shadowColor = 'transparent';
                        const link = document.createElement('a');
                        link.download = `cursor_${currentShape}_${exportSize}.png`;
                        link.href = tempCanvas.toDataURL();
                        link.click();
                        return;
                    }
                } else if (colors.length === 1) {
                    tempCtx.strokeStyle = hexToRgbA(colors[0], outlineOpacity);
                } else {
                    tempCtx.strokeStyle = hexToRgbA(outlineColor, outlineOpacity);
                }
            } else {
                tempCtx.strokeStyle = hexToRgbA(outlineColor, outlineOpacity);
            }
            tempCtx.lineWidth = scaledBorderThickness;
            tempCtx.stroke(outlinePath);
        }
        
        tempCtx.shadowBlur = 0;
        tempCtx.shadowColor = 'transparent';

        const link = document.createElement('a');
        link.download = `cursor_${currentShape}_${exportSize}.png`;
        link.href = tempCanvas.toDataURL();
        link.click();
    });

    updateControlsVisibility();
    drawCursor();
});
    </script>
</body>
</html>
